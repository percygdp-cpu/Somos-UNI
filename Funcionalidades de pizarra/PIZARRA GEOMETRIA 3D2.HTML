<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Pizarra Geo-Pro 3D - Edición Blindada</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #f1f3f5; }
        #toolbar { background: #2c3e50; padding: 10px; display: flex; gap: 8px; position: absolute; top: 0; width: 100%; z-index: 100; color: white; align-items: center; flex-wrap: wrap; box-shadow: 0 4px 10px rgba(0,0,0,0.3); border-bottom: 2px solid #3498db; }
        .group { border-right: 1px solid #555; padding: 0 10px; font-size: 10px; text-transform: uppercase; }
        button { padding: 7px 11px; cursor: pointer; border-radius: 4px; border: none; font-weight: bold; background: #ecf0f1; font-size: 11px; margin: 2px; color: #2c3e50; }
        button.active { background: #3498db; color: white; border: 1px solid white; }
        .swatch { width: 22px; height: 22px; border-radius: 50%; cursor: pointer; border: 2px solid white; display: inline-block; vertical-align: middle; margin-left: 5px; }
        .label-3d { position: absolute; background: #fff; color: #d35400; border: 2px solid #d35400; padding: 4px 8px; border-radius: 5px; font-size: 14px; pointer-events: none; font-weight: bold; transform: translate(-50%, -50%); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    </style>
</head>
<body>

<div id="toolbar">
    <div class="group">Formas<br>
        <button onclick="cambiarForma('cubo')">CUBO</button>
        <button onclick="cambiarForma('tetra')">TETRA</button>
        <button onclick="cambiarForma('cono')">CONO</button>
        <button onclick="cambiarForma('esfera')">ESFERA</button>
    </div>
    <div class="group">Navegación<br>
        <button id="btn-giro" class="active">GIRAR</button>
        <button id="btn-mover">MOVER</button>
        <button id="btn-escalar">ESCALAR</button>
    </div>
    <div class="group">Construcción<br>
        <button id="btn-puntoEje">1. PUNTOS</button>
        <button id="btn-segmento">2. SEGMENTO</button>
        <button id="btn-area">3. ÁREA</button>
        <button id="btn-angulo">4. ÁNGULO</button>
    </div>
    <div class="group">Color<br>
        <div class="swatch" style="background:#f1c40f" data-col="0xf1c40f"></div>
        <div class="swatch" style="background:#e74c3c" data-col="0xe74c3c"></div>
        <div class="swatch" style="background:#2ecc71" data-col="0x2ecc71"></div>
    </div>
    <button onclick="location.reload()" style="background:#e74c3c; color:white; margin-left:auto">REINICIAR</button>
</div>

<script>
    let scene, camera, renderer, raycaster, mouse, mainGroup;
    let modo = 'giro', isDragging = false, uPos = {x: 0, y: 0};
    let seleccionPuntos = [], puntosTemporales = [], labels = [], colorActual = 0xf1c40f;

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf1f3f5);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(10, 10, 12);
        camera.lookAt(0,0,0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        let sun = new THREE.DirectionalLight(0xffffff, 0.5);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        mainGroup = new THREE.Group();
        scene.add(mainGroup);
        raycaster = new THREE.Raycaster();
        raycaster.params.Line.threshold = 0.4; // Umbral alto para facilitar el clic
        mouse = new THREE.Vector2();

        cambiarForma('cubo');
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', () => isDragging = false);

        document.querySelectorAll('button[id^="btn-"]').forEach(btn => {
            btn.onclick = () => {
                modo = btn.id.replace('btn-', '');
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                limpiarTemporales(); seleccionPuntos = [];
            };
        });

        document.querySelectorAll('.swatch').forEach(s => s.onclick = () => colorActual = parseInt(s.dataset.col));
        animate();
    }

    function crearPuntoFisico(pos, temp = false) {
        const dot = new THREE.Mesh(
            new THREE.SphereGeometry(temp ? 0.08 : 0.12), 
            new THREE.MeshBasicMaterial({ color: temp ? 0xe74c3c : 0x2980b9, depthTest: false })
        );
        dot.position.copy(pos);
        dot.userData = { isVertex: true, isTemp: temp };
        dot.renderOrder = 100;
        mainGroup.add(dot);
        if(temp) puntosTemporales.push(dot);
        return dot;
    }

    function crearLineaFisica(p1, p2, col = 0x7f8c8d, op = 0.6) {
        const geo = new THREE.BufferGeometry().setFromPoints([p1.position, p2.position]);
        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: op }));
        line.userData = { isEdge: true, p1, p2 };
        mainGroup.add(line);
        return line;
    }

    function cambiarForma(tipo) {
        while(mainGroup.children.length > 0) mainGroup.remove(mainGroup.children[0]);
        labels = [];
        let dots = [];

        if(tipo === 'cubo') {
            const v = [[-2,-2,-2],[2,-2,-2],[2,2,-2],[-2,2,-2],[-2,-2,2],[2,-2,2],[2,2,2],[-2,2,2]];
            dots = v.map(p => crearPuntoFisico(new THREE.Vector3(...p)));
            [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].forEach(e => crearLineaFisica(dots[e[0]], dots[e[1]]));
        } else if(tipo === 'tetra') {
            const v = [[2,2,2], [-2,-2,2], [-2,2,-2], [2,-2,-2]];
            dots = v.map(p => crearPuntoFisico(new THREE.Vector3(...p)));
            [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]].forEach(e => crearLineaFisica(dots[e[0]], dots[e[1]]));
        } else if(tipo === 'cono') {
            const apex = crearPuntoFisico(new THREE.Vector3(0, 3, 0));
            for(let i=0; i<12; i++){
                let ang = (i/12)*Math.PI*2;
                dots.push(crearPuntoFisico(new THREE.Vector3(Math.cos(ang)*2.5, -1, Math.sin(ang)*2.5)));
            }
            dots.forEach((d, i) => {
                crearLineaFisica(d, dots[(i+1)%12]);
                crearLineaFisica(d, apex);
            });
        } else if(tipo === 'esfera') {
            for(let j=0; j<=4; j++) {
                let phi = (j/4)*Math.PI;
                for(let i=0; i<8; i++) {
                    let theta = (i/8)*Math.PI*2;
                    dots.push(crearPuntoFisico(new THREE.Vector3(2.5*Math.sin(phi)*Math.cos(theta), 2.5*Math.cos(phi), 2.5*Math.sin(phi)*Math.sin(theta))));
                }
            }
            for(let j=0; j<=4; j++) {
                for(let i=0; i<8; i++) {
                    let idx = j*8 + i;
                    if(i<7) crearLineaFisica(dots[idx], dots[idx+1]); else crearLineaFisica(dots[idx], dots[idx-7]);
                    if(j<4) crearLineaFisica(dots[idx], dots[idx+8]);
                }
            }
        }
    }

    function onMouseDown(e) {
        if (e.target.tagName === 'BUTTON' || e.target.className === 'swatch') return;
        isDragging = true;
        uPos = {x: e.clientX, y: e.clientY};
        mouse.x = (e.clientX/window.innerWidth)*2-1;
        mouse.y = -(e.clientY/window.innerHeight)*2+1;
        raycaster.setFromCamera(mouse, camera);
        
        const hits = raycaster.intersectObjects(mainGroup.children);
        const pointHit = hits.find(i => i.object.userData.isVertex);
        const lineHit = hits.find(i => i.object.userData.isEdge);

        if (modo === 'puntoEje') {
            if (pointHit && pointHit.object.userData.isTemp) {
                crearPuntoFisico(pointHit.object.position.clone(), false);
                limpiarTemporales();
            } else if (lineHit) {
                limpiarTemporales();
                const p1 = lineHit.object.userData.p1.position, p2 = lineHit.object.userData.p2.position;
                for(let i=1; i<10; i++) {
                    let pos = new THREE.Vector3().lerpVectors(p1, p2, i/10);
                    crearPuntoFisico(pos, true);
                }
            }
        } else if (modo === 'segmento' && pointHit && !pointHit.object.userData.isTemp) {
            seleccionPuntos.push(pointHit.object);
            if(seleccionPuntos.length === 2) { 
                crearLineaFisica(seleccionPuntos[0], seleccionPuntos[1], 0x2c3e50, 1); 
                seleccionPuntos = []; 
            }
        } else if (modo === 'area' && pointHit && !pointHit.object.userData.isTemp) {
            seleccionPuntos.push(pointHit.object);
            if(seleccionPuntos.length > 2 && pointHit.object === seleccionPuntos[0]) {
                const geo = new THREE.BufferGeometry().setFromPoints(seleccionPuntos.map(p => p.position));
                const idx = []; for(let i=1; i<seleccionPuntos.length-1; i++) idx.push(0, i, i+1);
                geo.setIndex(idx);
                mainGroup.add(new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: colorActual, side: THREE.DoubleSide, transparent: true, opacity: 0.7 })));
                seleccionPuntos = [];
            }
        } else if (modo === 'angulo' && pointHit && !pointHit.object.userData.isTemp) {
            seleccionPuntos.push(pointHit.object.position.clone());
            if(seleccionPuntos.length === 3) {
                let v = prompt("Ingresa el valor del ángulo:", "90°");
                if(v) labels.push({pos: seleccionPuntos[1].clone(), text: v});
                seleccionPuntos = [];
            }
        }
    }

    function onMouseMove(e) {
        if (!isDragging) return;
        const dx = (e.clientX - uPos.x)*0.01, dy = (e.clientY - uPos.y)*0.01;
        if(modo === 'giro') { mainGroup.rotation.y += dx; mainGroup.rotation.x += dy; }
        else if(modo === 'mover') { mainGroup.position.x += dx*10; mainGroup.position.y -= dy*10; }
        else if(modo === 'escalar') { let s = 1 + dx; mainGroup.scale.multiplyScalar(s); }
        uPos = {x: e.clientX, y: e.clientY};
    }

    function limpiarTemporales() { puntosTemporales.forEach(p => mainGroup.remove(p)); puntosTemporales = []; }

    function animate() {
        requestAnimationFrame(animate);
        document.querySelectorAll('.label-3d').forEach(l => l.remove());
        labels.forEach(l => {
            let p = l.pos.clone().applyMatrix4(mainGroup.matrixWorld);
            let v = p.project(camera);
            let div = document.createElement('div'); 
            div.className = 'label-3d';
            div.style.left = (v.x+1)/2 * window.innerWidth + 'px';
            div.style.top = -(v.y-1)/2 * window.innerHeight + 'px';
            div.innerText = l.text; 
            document.body.appendChild(div);
        });
        renderer.render(scene, camera);
    }
    init();
</script>
</body>
</html>